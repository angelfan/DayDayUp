# Postgresql Index

[Explain](https://www.postgresql.org/docs/9.4/static/using-explain.html)
[Index Types](https://www.postgresql.org/docs/9.3/static/indexes-types.html)
[索引的工作原理](https://dreamer-yzy.github.io/2015/01/05/-%E8%BD%AC%E8%BD%BD-%E4%BD%A0%E7%9F%A5%E9%81%93%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F/)



尽量减少like，但不是绝对不可用 ”xxxx%” 不会用到索引的
不同的索引类型支持不同条件的索引

## Note
需要注意的是并不是建立了索引在查询的时候就一定会用到索引
当返回行数非常多的时候就不会索引扫描
这是因为索引扫描，需要为每一行多个IO操作（查找行中的索引，然后检索来自堆的行）。
而顺序扫描仅需要为每一行的单个IO - 或甚至更少，因为在盘上的块（页）包含多个行，因此一个以上的行可以用单个IO操作获取。

由于索引只能提高搜索记录中某个匹配字段的速度，因此在执行插入和删除操作的情况下，
仅为输出结果而为字段建立索引，就纯粹是浪费磁盘空间和处理时间了；这种情况下不用建立索引。
另外，由于二分查找的原因，数据的基数性（cardinality）或唯一性也非常重要。
对基数性为2的字段建立索引，会将数据一分为二，而对基数性为1000的字段，则同样会返回大约1000条记录。
在这么低的基数性下，索引的效率将减低至线性查找的水平，
而查询优化器会在基数性小于记录数的30%时放弃索引，实际上等于索引纯粹只会浪费空间。

一般来说，列的值唯一性太小（如性别，类型什么的），不适合建索引



分块因数为 bfr = (B/R)
B => 数据库块大小
R => 每条记录分配

保存整个表所需的数据块数 N = (r/bfr)
r => 表记录数
